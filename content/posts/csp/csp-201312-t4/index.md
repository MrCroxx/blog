---
title: "CSP 201312 T4 有趣的数"
date: 2019-07-10T15:10:30+08:00
draft: false
categories: ["CCF CSP"]
tags: ["CCF CSP","Algorithm"]
featuredImage: img/ccf-csp.jpg
---

*本文为原创文章，转载请严格遵守[CC BY-NC-SA协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)。*

<!--more-->

# CCF CSP 201312 T4 有趣的数

## 题目

### **问题描述**

我们把一个数称为有趣的，当且仅当：

1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。
2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。
3. 最高位数字不为0。

因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。

请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。

### 输入格式

输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。

### 输出格式

输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。

### 样例输入

```
4
```

### 样例输出

```
3
```

### 时间限制

```
1.0s
```

### 内存限制

```
256.0MB
```

## 题解

递推问题。

首先观察规则，我们可以总结出如下的规则：

1. 首位必须为2；
2. 所有0都在任意1前；
3. 所有2都在任意3前。
4. 0、1、2、3必须出现至少一次。

在计算时，我们其实只需要考虑前三条规则。

我们设`f[i][b0][b1][b2][b3]`为`长度为i的、满足规则123的有趣的数的个数，其中b0、b1、b2、b3表示0、1、2、3是否在这个数中出现`。

例如，“满足规则123的、0、1、2、3都出现的、长度为4的有趣的数的个数为3”可表示为`f[4][1][1][1][1]=3`。

考虑规则123，动态转移方程可表示为：

```
f[i][0][0][1][0] = 1;
f[i][1][0][1][0] = f[i - 1][1][0][1][0] * 2 + f[i - 1][0][0][1][0];
f[i][1][1][1][0] = f[i - 1][1][1][1][0] * 2 + f[i - 1][1][0][1][0];
f[i][0][0][1][1] = f[i - 1][0][0][1][1] + f[i - 1][0][0][1][0];
f[i][1][0][1][1] = f[i - 1][1][0][1][1] * 2 + f[i - 1][0][0][1][1] + f[i - 1][1][0][1][0];
f[i][1][1][1][1] = f[i - 1][1][1][1][1] * 2 + f[i - 1][1][0][1][1] + f[i - 1][1][1][1][0];
其余均为0。
```

可见，其实有效的状态只有6种，可以按照6中状态进行压缩，由于<s>( 我懒 )</s>本题空间足够，也可以不压缩。

最后输出的答案即`f[n][1][1][1][1]`。

## 代码

```c++
#include <iostream>
#include <cstring>

#define N 1050
#define ll long long

using namespace std;
ll f[N][2][2][2][2];
ll m = 1000000007;

int main()
{
    int n;
    memset(f, 0, sizeof(f));

    cin >> n;
    f[1][0][0][1][0] = 1;
    for (int i = 2; i <= n; i++)
    {
        f[i][0][0][1][0] = 1;
        f[i][1][0][1][0] = ((f[i - 1][1][0][1][0] * 2) % m + f[i - 1][0][0][1][0]) % m;
        f[i][1][1][1][0] = ((f[i - 1][1][1][1][0] * 2) % m + f[i - 1][1][0][1][0]) % m;
        f[i][0][0][1][1] = (f[i - 1][0][0][1][1] + f[i - 1][0][0][1][0]) % m;
        f[i][1][0][1][1] = ((f[i - 1][1][0][1][1] * 2) % m + f[i - 1][0][0][1][1] + f[i - 1][1][0][1][0]) % m;
        f[i][1][1][1][1] = ((f[i - 1][1][1][1][1] * 2) % m + f[i - 1][1][0][1][1] + f[i - 1][1][1][1][0]) % m;
    }
    cout << f[n][1][1][1][1];
    return 0;
}
```
