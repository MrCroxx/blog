---
title: "《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》论文翻译[持续更新中]"
date: 2020-10-08T16:02:56+08:00
lastmod: 2020-10-08T16:02:56+08:00
draft: false
keywords: []
description: ""
tags: ["MVCC", "Translation"]
categories: ["Paper Reading"]
author: ""
resources:
- name: featured-image
  src: paper-reading.jpg
---

*本篇文章是对论文[An Empirical Evaluation of In-Memory Multi-Version Concurrency Control](https://15721.courses.cs.cmu.edu/spring2019/papers/03-mvcc1/wu-vldb2017.pdf)的原创翻译，转载请严格遵守[CC BY-NC-SA协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)。*

<!--more-->

## 作者

Yingjun Wu National University of Singapore yingjun@comp.nus.edu.sg

Joy Arulraj Carnegie Mellon University jarulraj@cs.cmu.edu

Jiexi Lin Carnegie Mellon University jiexil@cs.cmu.edu

Ran Xian Carnegie Mellon University rxian@cs.cmu.edu

Andrew Pavlo Carnegie Mellon University pavlo@cs.cmu.edu

## 摘要

多版本并发控制（Multi-version concurrency control，MVCC）目前是现代数据库管理系统（DBMS）中最热门的事务管理策略。尽管MVCC在1970年代晚期就已经被发明出来了，但是在过去的十年中，在几乎所有主要的关系型DBMS中都使用了它。在处理事务时，维护数据的多个版本可以在不牺牲串行性的同时提高并行性。但是在多核和内存的配置中扩展MVCC并非易事：当有大量线程并行运行时，同步带来的开销可能超过多版本带来的好处。

为了理解在现代的硬件配置下处理事务时MVCC如何执行，我们对MVCC的4个关键设计决策进行了大量研究：并发控制协议、版本存储、垃圾回收、和索引管理。我们在内存式DBMS中以最高水平实现了这些所有内容的变体，并通过OLTP负载对它们进行了评估。我们的分析确定了每种设计选择的基本瓶颈。

## 1. 引言

计算机体系结构的进步导致了多核内存式DBMS的兴起，它们使用了高效的事务管理机制以在不牺牲串行性的同时提高并行性。在最近十年的里，在DBMS开发中使用的最流行的策略是*多版本并发控制（multi-version concurrency control，MVCC）* 。MVCC的基本想法是，DBMS为数据库中的每个逻辑对象维护多个物理版本，让对同一个对象的操作能够并行执行。这些对象可以是任何粒度上的，但是几乎所有的MVCC DBMS都使用了元组（tuple），因为它在并行性和版本追踪（version tracking）的开销间提供了很好的平衡。多版本化可以让只读的事务访问元组的旧版本，而不会阻止读写事务在同事生成新的版本。这与单版本的系统不同，在单版本系统中，事务总是会在更新一个元组时时用新数据覆写它。

最近DBMS使用MVCC的这一趋势的有趣之处在于，MVCC策略并不是新技术。第一次提到MVCC似乎是在1979年的一篇论文中<sup>[38]</sup>，它的第一个实现始于1981年的InterBase DBMS<sup>[22]</sup>（现在作为Firebird开源）。如今，MVCC还用于一些部署最广泛的面向磁盘的DBMS中，包括Oracle（自1984年起<sup>[4]</sup>），Postgres（自1985年起<sup>[41]</sup>）和MySQL的InnoDB引擎（自2001年起）。但是，尽管有很多与这些较早的系统同时代的系统使用了单版本策略（例如，IBM DB2、Sybase），但是几乎所有新的支持事务的DBMS都避开了单版本策略转而使用MVCC<sup>[37]</sup>。无论商业系统（例如，Microsoft Hekaton<sup>[16]</sup>、SAP HANA<sup>[40]</sup>、MemSQL<sup>[1]</sup>、NuoDB<sup>[3]</sup>）还是学术系统（例如，HYRISE<sup>[21]</sup>、HyPer<sup>[36]</sup>）都是如此。

尽管所有的这些新系统都使用了MVCC，但是MVCC并没有一个“标准”实现。在一些设计中选择了不同的权衡点（trade-off）和性能表现。直到现在，都没有在现代DBMS操作环境中的对MVCC的全面的评估。最近的大量的研究在1980年代<sup>[13]</sup>，但是它在单核CPU上运行的面向磁盘的DBMS中使用了模拟的负载。古老的面向磁盘的DBMS的设计上的选择并不适用于运行在有更多CPU核数的机器上的内存式DBMS。因此，这项过去的研究并不能反映出最近的无闩（latch-free）<sup>[27]</sup>和串行<sup>[20]</sup>的并发控制与内存式存储<sup>[36]</sup>和混合负载<sup>[40]</sup>的趋势。

在本文中，我们对MVCC DBMS中关键的事务管理设计决策进行了研究：（1）并发控制协议（concurrency control protocol）（2）版本存储（version storage）（3）垃圾回收（garbage collection）（4）索引管理（index management）。对于每一个主题，我们都描述了内存式DBMS中的最先进的实现，并讨论了它们的做出的权衡。我们还重点介绍了阻止它们扩展以支持更多线程数和更复杂的负载的问题。作为调研的一部分，我们在内存式MVCC DBMS **Peloton**<sup>[5]</sup>中实现了所有的这些方法。这为我们提供了可以比较这些实现的统一的平台，且不受没实现的架构设计所影响。我们在40核的机器上部署了Peloton，并通过两个OLTP benchmark对其进行评估。我们的分析确定了对我们的实现造成压力的场景，并讨论了缓解它们的方式（如果可能的话）。

## 2. 背景

我们首先提供了MVCC的上层概念的总览。然后讨论了DBMS追踪事务与维护版本信息用的元数据。

### 2.1 MVCC总览

事务管理策略让终端用户能够通过多个程序访问数据库且让每个用户以为自己在一个单独的专用系统上执行<sup>[9]</sup>。它确保了DBMS的原子性和隔离性的保证。

对于现代数据库程序来说，多版本系统有一些优势。其中最重要的是，多版本系统比单版本系统能支持更高的并发。例如，MVCC DBMS允许在一个事务读一个对象的较旧的版本的同时另一个事务更新该对象。这一点十分重要，因为数据库执行只读查询的同时读写事务能够继续更新它。如果DBMS永远都不移除旧版本，那么系统就能够支持“时间旅行”操作，让应用程序能够像在过去的某个时间点一样查询数据库的快照<sup>[8]</sup>。

以上的好处让MVCC成为近些年DBMS的实现中最流行的选择。**表1** 提供了过去30年中MVCC的实现的总结。然而，在DBMS中实现多版本有很多种方式，每种方法都会产生不同的额外计算与存储开销。这些设计上的决策也高度互相依赖。因此，判断哪些设计决策比其它的好且为什么比其它的好并非易事。而在磁盘不再成为瓶颈的内存式DBMS中更是这样。

![表1 对商业和研究用MVCC DBMS中的设计决策的总结。每个系统的“Year”（Oracle除外）是它首次发布或宣布的时间。对于Oracle，“Year”是其首次包含了MVCC的年份。除了Oracle、MySQL和Postgres外，所有的系统都宣称它们的数据库的主要存储位置是内存。](table-1.png "表1 对商业和研究用MVCC DBMS中的设计决策的总结。每个系统的“Year”（Oracle除外）是它首次发布或宣布的时间。对于Oracle，“Year”是其首次包含了MVCC的年份。除了Oracle、MySQL和Postgres外，所有的系统都宣称它们的数据库的主要存储位置是内存。")

在接下来的章节中，我们将讨论这些设计决策实现上的问题和性能权衡点。接着我们在[第7章](#7-)对它们进行了全面的评估。我们注意到，本文中仅考虑了串行事务执行。尽管日志和恢复是DBMS架构中很重要方面，但是我们的研究中并没有包括它们，因为它们与单版本系统中的没什么不同，且内存式DBMS日志已经在别处被研究过了<sup>[39, 49]</sup>。

### 2.2 DBMS元数据

无论实现方式如何，MVCC DBMS都会维护用于事务和数据库元组的通用的元数据。

**事务：** 当事务$T$首次进入DBMS系统时，DBMS会为该事务分配一个唯一、单调递增的时间戳作为它的标识符（$ T_{id} $）。并发控制协议使用这种标识符来标记事务访问的元组的版本。一些协议还用它作为事务串行的顺序。

**元组：** 如**图1**所示，每个“物理”版本在它的头部中都包括4个元数据字段，DBMS用它来协调并发事务的执行（下一章中讨论的一些并发控制协议包括了额外的字段）。`txn-id`字段被用作版本的写入锁。如果元组没被锁定写入，那么该元组的这一字段会被置零。大部分的DBMS都使用64位的`txn-id`，这样它可以通过一次compare-and-swap（CaS）指令原子性的更新该值。如果标识符为$ T_{id} $的事务$T$想要更新元组$A$，那么DBMS会检查$A$的`txn-id`字段是否为零。如果是，那么DBMS会通过一个CaS指令将`txn-id`置为$ T_{id} $<sup>[27, 44]</sup>。如果一个事务试图更新$A$，当这一`txn-id`既不是0也不等于该事务的$ T_{id} $时，该事务会被打断。接下来的两个元数据字段是`begin-ts`和`end-ts`，它们记录了表示元组版本生命周期的时间戳。这两个字段最初都会被置零。DBMS会在事务删除元组时把改元组的`begin-ts`置为INF。最后一个元数据字段是一个保存相邻（前一个或后一个）版本的地址的指针（如果有的话）。

![图1 元组格式——元组的一个物理版本的基本布局。](figure-1.png "图1 元组格式——元组的一个物理版本的基本布局。")

## 3. 并发控制协议

每个DBMS都有一个用来协调并发事务执行的*并发控制协议* <sup>[11]</sup>。该协议确定了（1）在数据库运行时中，是否允许某个事务访问或修改一个特定的元组版本（2）是否允许某个事务提交它的修改。尽管这些协议的基本原理从1980年代就没改变过，但是在没有磁盘操作的多核和内存为主的配置下，它们的性能特征已经发生了巨大的变化<sup>[42]</sup>。因此，有些新兴的高性能的DBMS变体移除了锁（lock）/闩（latch）和中心化的数据结构，并为字节可寻址存储（byte-addressable storage）进行了优化。

本章中，我们描述了MVCC DBMS的4中核心并发控制协议。我们仅考虑了使用元祖级锁的协议，因为这足以确保串行化执行。我们忽略了范围查询，因为多版本没有为防止幻读带来任何好处<sup>[7]</sup>。已有的提供了串行事务处理的方法，（1）或者在索引上使用了额外的闩<sup>[35, 44]</sup>，（2）或者在事务提交时使用了额外的校验步骤<sup>[27]</sup>。

### 3.1 时间戳排序（Timestamp Ordering）——MVTO

1979年的MVTO算法被认为是最初的并发控制协议<sup>[38, 39]</sup>。该方法的核心在于使用事务的标识符（$ T_{id} $）来预计算它们的串行顺序。除了[章节2.2](#22-)中描述的字段以外，其版本头中还包括最后一次读取了它的事务的标识符（`read-ts`）。当事务视图读取或更新一个被其它事务持有其写入锁的版本时，DBMS会打断该事务。

当事务$T$在逻辑元组$A$上调用了一个读操作时，DBMS会搜索一个能使该$ T_{id} $在其`begin-ts`和`end-ts`字段的范围间的物理版本。如**图2a**所示，如果版本$A_x$的写入锁没有被另一个活动的事务持有（即，`txn-id`的值为0或等于$ T_{id} $），那么$T$会被允许读取该版本，因为MVTO永远不会允许一个事务读取未提交的版本。一旦事务读取了$A_x$，如果$A_x$的`read-ts`字段的当前值小于$ T_{id} $，那么DBMS会将其置为$ T_{id} $。否则，该事务将读取一个较旧的版本，且不会更新该字段。

![图2 并发控制协议——协议如何处理先执行READ然后执行UPDATE的事务的示例。](figure-2.png "图2 并发控制协议——协议如何处理先执行READ然后执行UPDATE的事务的示例。")

通过MVTO，事务总能更新元组的最新版本。如果（1）没有持有$B_x$的写入锁的活动的事务，且（2）$ T_{id} $的值比$B_x$的`read-ts`字段大，事务$T$会创建一个新版本$ B_{x+1} $。如果这些条件被满足，那么DBMS会创建一个新版本$ B_{x+1} $并将其`txn-id`置为$ T_{id} $。当$T$提交时，DBMS会分别将$ B_{x+1} $的`begin-ts`和`end-ts`字段置为$ T_{id} $和INF，并将$B_x$的`end-ts`字段置为$ T_{id} $。

### 3.2 乐观并发控制（Optimistic Concurrency Control）——MVOCC

接下来的协议基于1981年提出的乐观并发控制策略（OCC）<sup>[26]</sup>。OCC背后的动机是，DBMS假设事务冲突的可能性不大，因此当事务读取或更新元组时没有必要获取元组上的锁。这减少了事务持有锁的总时间。为了使原始的OCC协议适应多版本，需要对它作出一些修改<sup>[27]</sup>。其中最重要的是，DBMS不会为事务维护一个私有的工作空间（workspace），因为元组的版本信息已经防止了事务读取或更新应对它们不可见的版本。

MVOCC协议将事务分为了3个阶段。当事务开始时，它处于*读阶段（read phase）* 。这是事务在数据库上调用读或更新操作的阶段。与MVTO相似，为了在元组$A$上执行读操作，DBMS首先会基于元组的`begin-ts`和`end-ts`字段搜索一个可见的版本$A_x$。如果版本$A_x$的写入锁没被获取，那么$T$会被允许更新该版本。在多版本配置下，如果事务更新了版本$B_x$，那么DBMS会创建版本$ B_{x+1} $并将其`txn-id`置为$ T_{id} $。

当事务告知DBMS它要提交时，事务会进入*校验阶段（validation phase）* 。首先，DBMS会为该事务分配另一个时间戳（$ T_{commit} $）来确定该事务读取的元组的集合是否被一个已提交的事务更新了。如果该事务通过过了这些检查，那么它会进入*写阶段（write phase）* ，在这一阶段DBMS会安装（install）所有的新版本且将它们的`begin-ts`置为$ T_{commit} $并将`end-ts`置为INF。

事务只能更新元组的最新的版本。但是事务在其它事务创建新版本的提交前，它都不能读该新版本。读到过时版本的事务仅会在校验阶段发现它应该终止。

### 3.3 两阶段锁（Two-phase Locking）——MV2PL

该协议使用了两阶段锁（2PL）的方法<sup>[11]</sup>来确保事务的串行性。每个事务在被允许读取或修改逻辑元组的当前版本前，需要获取适当的锁。在基于磁盘的DBMS中，锁会与元组分开存储，这样锁永远不会被换出（swap）到磁盘中。而在内存式DBMS中，分开存储时不必要的，因此使用MV2PL时，锁被嵌入在了元组的头部中。元组的*写入锁* 是`txn-id`字段。而对于*读取锁* ，DBMS使用`read-cnt`字段对读取该元组的活动的事务计数。尽管不是必需的，DBMS还是将`txn-id`和`read-cnt`装入连续的64位字中，这样DBMS可以使用一个CaS指令来同时更新它们。

为了对元组$A$执行读操作，DBMS会通过将事务的$ T_{id} $和元组的`begin-ts`进行比较来搜索一个可见的版本。如果它找到了一个有效地版本，DBMS会在它的`txn-id`字段等于零时（这意味着没有其它的事务持有着它的写入锁）将该元组的`read-cnt`字段加一。类似地，当事务仅在版本$B_x$的`read-cnt`和`txn-id`都被置为零使才被允许更新它。当事务提交时，DBMS会为它分配一个唯一的时间戳$ T_{commit} $，其被用于更新由该事务创建的其它版本的`begin-ts`字段，并随后释放该事务所有的锁。

2PL协议间的关键区别在于它们如何处理死锁。之前的研究表明*无等待（no-wait）* 策略<sup>[9]</sup>是可伸缩性最好的防死锁技术<sup>[48]</sup>。使用这一策略，DBMS会在事务不能获取元组的锁时立刻打断它（与等待并看锁是否被释放相反）。因为事务永远不会等待，DBMS没必要使用一个后台线程来检测并打破死锁。

### 3.4 串行验证者（Serialization Certifier）

在最后一个协议中，DBMS会维护一个串行图（serialization graph）来检测并移除当前事务形成的“危险结构”<sup>[12, 20, 45]</sup>。在较弱的隔离界别之上可以采用基于验证着的方法，这能提供更好的性能但是允许出现某些异常情况。

第一个提出验证者方法的是可串行快照隔离（serializable snapshot isolation，SSI）<sup>[12]</sup>。这种方法通过避免写倾斜的异常（write-skew anomly）来确保串行性以提供快照隔离。SSI使用事务的标识符来索索元组的可见版本。事务仅当元组的`txn-id`字段被置为零时才能更新其版本。为了确保串行性，当事务创建了一个元组的新版本同时该元组之前的版本被另一个事务读取时，DBMS会在其内部的图中追踪*反依赖（anti-dependency）* 边。DBMS会为每个事务维护一些标识（flag）以追踪反依赖边的入度和出度。当DBMS检测到两个事务间有两个连续的反依赖边时，它会打断其中一个事务。

串行安全网络（serial safety net，SSN）是一种新兴的基于验证着的协议<sup>[45]</sup>。不像仅适用于快照隔离的SSI，SSN能在强度至少与READ COMMITTED相同的任何隔离界别中工作。它还是用了更精确的异常检测机制，减少了被不必要打断的事务的数量。SSN将事务依赖信息编码为元数据字段，并通过计算一个能汇总在$T$之前提交但必须在T之后串行执行的“危险”事务的“低水位标记（low watermark）”来校验事务$T$的一致性<sup>[45]</sup>。SSn能够减少错误打断的数量，这使它更适用于只读或以读取为主的事务负载。

### 3.5 探讨

这些协议处理冲突的方式不同，因此在某些负载下，一些协议会比其它协议更好。MV2PL使用每个版本的读取锁来记录读取。因此，对一个元组版本执行读或写的事务会导致另一个试图对该版本做相同操作的事务终止。而MVTO使用了每个版本的`read-ts`字段来记录读取。MVOCC在处理读操作时不会更新元组版本头部的任何字段。这避免了线程间不必要的协调，且读取某一版本的事务不会导致其它更新相同版本的事务被打断。但是MVOCC要求DBMS检验事务的读集合以验证该事务读操作的正确性。这可能导致长期运行的只读事务长时间不会被执行（译注：原文为“starvation”）<sup>[24]</sup>。而验证者协议因不需要验证读取而减少了事务打断，但是它们的反依赖检查策略可能会带来额外的开销。

一些协议优化了上面的协议以改进它们在MVCC DBMS中的功效<sup>[10, 27]</sup>。一种方法让事务能够*预先读取（speculatively）* 其它事务创建的未提交的版本。而作为权衡，协议必须追踪事务的读依赖以确保可以串行排序。每个worker线程会维护一个*依赖计数器（dependency counter）* ，以计数该事务读取的未提交的数据对应的事务的个数。事务仅在它的依赖计数器为零时才被允许提交，因此，在事务提交时DBMS会遍历其以来列表并减小所有等待它完成的事务的计数器。类似地，另一种优化机制让事务能够*预先更新（eagerly update）* 被其它未提交的事务读取的版本。这一优化也需要DBMS维护中心化数据结构以追踪事务间的依赖。一个事务仅当所有它依赖的事务已经提交后才能提交。

以上描述的两种优化都能减少某些负载下不必要的打断数量，但是它们都收级联终止（cascading abort）影响。此外，我们发现维护中心化数据结构可能成为主要的性能瓶颈，这会让DBMS不能扩展到几十个核心的配置。

## 4. 版本存储

