---
title: "《Paxos Made Live - An Engineering Perspective》论文翻译 [持续更新中]"
date: 2020-09-24T11:42:43+08:00
lastmod: 2020-09-24T11:42:43+08:00
draft: false
keywords: []
description: ""
tags: ["Paxos", "Translation"]
categories: ["Paper Reading"]
author: ""
resources:
- name: featured-image
  src: paper-reading.jpg
---

*本篇文章是对论文[Paxos Made Live - An Engineering Perspective](http://www8.cs.umu.se/kurser/5DV153/HT14/literature/chandra2006paxos.pdf)的原创翻译，转载请严格遵守[CC BY-NC-SA协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)。*


<!--more-->

## 摘要

我们描述了我们在使用Paxos共识算法构建一个容错的数据库的经历。尽管在该领域已经有文献，但是事实上构建这样一个数据库并非易事。我们描述了选取算法和遇到的工程问题，及我们对这些问题的解决方案。我们的度量表明我们构建了一个很有竞争力的系统。

## 1. 引言

众所周知，在商用硬件上的容错可通过副本实现<sup>[17, 18]</sup>。一个更通用的方法是使用共识算法<sup>[7]</sup>来确保所有副本相互一致<sup>[8, 14, 17]</sup>。通过对输入值的序列反复应用这样的算法，使为每个副本构建相同的值的日志成为可能。如果值是对某个数据结构的操作，那么建立在所有副本的相同日志上的应用程序可被用作实现所有副本中相互一致的数据结构。例如，如果日志由数据库操作序列组成，且对每个副本上的（本地）数据库应用了相同的操作序列，那么最终所有副本会有相同的数据库内容（前提是它们都从相同的初始数据库状态开始）。

这种通用的方法可被用作实现很多种容错基本组件，可容错数据库仅是一个例子。因此，在过去20年中，共识问题被大量研究。其中有几个众所周知的共识算法，它们可以在多种设置下执行，并能够容忍各种故障。Paxos算法<sup>[8]</sup>已经被从理论<sup>[16]</sup>和应用<sup>[10, 11, 12]</sup>的社区中被讨论了超过10年。

我们使用Paxos算法（Paxos）作为实现了容错日志的框架的基础。接着，我们依赖这个框架构建了一个容错数据库。尽管在这个方向已经有文献，但是构建一个生产级的系统并非易事，其原因有如下几点：

- 尽管Paxos能被一页伪代码描述出来，但是我们的完整实现却有几千行C++代码。代码量的爆炸并非由于我们使用了C++而不是伪代码，也不是由于我们的代码风格很啰嗦。将算法转化为实用的、可用于生产的系统，需要实现很多特性和优化——其中一些在文献中发表过，而一些却没有。

- 容错算法社区习惯于证明短算法的正确性（一页伪代码）。但是这种方法不适用于证明由几千行代码组成的系统的正确性。为了在真实系统中获取对“正确性”的自信，我们使用了很多不同的方法。

- 容错算法能够容忍一系列被小心选取的故障。然而，真实世界中的软件面对着各种各样的故障模式，包括算法中的错误、实现中的bug、和操作错误。我们必须设计软件并设计操作程序，以更健壮地处理更大范围的故障模式。

- 一个真是的系统很少能够精确地定义。甚至更糟的是，定义可能在实现阶段变化。因此，系统的实现应该是易修改的。最后，系统构建可能因为在其定义阶段的误解而失败。

本文挑选了我们在将Paxos从理论搬到实践过程中遇到的一些算法和工程挑战。这一工作比直接将伪代码翻译为C++多出很多研究与开发上的努力。

本文剩下的部分按照如下方式组织。